// Code generated by sqlc. DO NOT EDIT.
// source: collection.sql

package db

import (
	"context"
	"time"
)

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (
  user_id, name, description, blockchain,
  owners, payment_token, creator_earning, featured_img,
  banner_img, ins_link, twitter_link, website_link, contract_address
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, user_id, name, description, blockchain, owners, payment_token, creator_earning, featured_img, banner_img, ins_link, twitter_link, website_link, created_at, updated_at, contract_address
`

type CreateCollectionParams struct {
	UserID          int64  `json:"user_id"`
	Name            string `json:"name"`
	Description     string `json:"description"`
	Blockchain      string `json:"blockchain"`
	Owners          string `json:"owners"`
	PaymentToken    string `json:"payment_token"`
	CreatorEarning  string `json:"creator_earning"`
	FeaturedImg     string `json:"featured_img"`
	BannerImg       string `json:"banner_img"`
	InsLink         string `json:"ins_link"`
	TwitterLink     string `json:"twitter_link"`
	WebsiteLink     string `json:"website_link"`
	ContractAddress string `json:"contract_address"`
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRowContext(ctx, createCollection,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Blockchain,
		arg.Owners,
		arg.PaymentToken,
		arg.CreatorEarning,
		arg.FeaturedImg,
		arg.BannerImg,
		arg.InsLink,
		arg.TwitterLink,
		arg.WebsiteLink,
		arg.ContractAddress,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Blockchain,
		&i.Owners,
		&i.PaymentToken,
		&i.CreatorEarning,
		&i.FeaturedImg,
		&i.BannerImg,
		&i.InsLink,
		&i.TwitterLink,
		&i.WebsiteLink,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContractAddress,
	)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections
WHERE id = $1
`

func (q *Queries) DeleteCollection(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCollection, id)
	return err
}

const getCollection = `-- name: GetCollection :one
SELECT collections.id, collections.user_id, collections.name, collections.description, collections.blockchain, collections.owners, collections.payment_token, collections.creator_earning, collections.featured_img, collections.banner_img, collections.ins_link, collections.twitter_link, collections.website_link, collections.created_at, collections.updated_at, collections.contract_address, users.username created_by FROM collections, users
WHERE collections.user_id = users.id
AND collections.id = $1
LIMIT 1
`

type GetCollectionRow struct {
	ID              int64     `json:"id"`
	UserID          int64     `json:"user_id"`
	Name            string    `json:"name"`
	Description     string    `json:"description"`
	Blockchain      string    `json:"blockchain"`
	Owners          string    `json:"owners"`
	PaymentToken    string    `json:"payment_token"`
	CreatorEarning  string    `json:"creator_earning"`
	FeaturedImg     string    `json:"featured_img"`
	BannerImg       string    `json:"banner_img"`
	InsLink         string    `json:"ins_link"`
	TwitterLink     string    `json:"twitter_link"`
	WebsiteLink     string    `json:"website_link"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	ContractAddress string    `json:"contract_address"`
	CreatedBy       string    `json:"created_by"`
}

func (q *Queries) GetCollection(ctx context.Context, id int64) (GetCollectionRow, error) {
	row := q.db.QueryRowContext(ctx, getCollection, id)
	var i GetCollectionRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Blockchain,
		&i.Owners,
		&i.PaymentToken,
		&i.CreatorEarning,
		&i.FeaturedImg,
		&i.BannerImg,
		&i.InsLink,
		&i.TwitterLink,
		&i.WebsiteLink,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContractAddress,
		&i.CreatedBy,
	)
	return i, err
}

const getTotalCollection = `-- name: GetTotalCollection :one
SELECT count(*) FROM collections
`

func (q *Queries) GetTotalCollection(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalCollection)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listCollections = `-- name: ListCollections :many
SELECT collections.id, collections.user_id, collections.name, collections.description, collections.blockchain, collections.owners, collections.payment_token, collections.creator_earning, collections.featured_img, collections.banner_img, collections.ins_link, collections.twitter_link, collections.website_link, collections.created_at, collections.updated_at, collections.contract_address, users.username created_by FROM collections, users
WHERE collections.user_id = users.id
ORDER BY updated_at
LIMIT $1
OFFSET $2
`

type ListCollectionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListCollectionsRow struct {
	ID              int64     `json:"id"`
	UserID          int64     `json:"user_id"`
	Name            string    `json:"name"`
	Description     string    `json:"description"`
	Blockchain      string    `json:"blockchain"`
	Owners          string    `json:"owners"`
	PaymentToken    string    `json:"payment_token"`
	CreatorEarning  string    `json:"creator_earning"`
	FeaturedImg     string    `json:"featured_img"`
	BannerImg       string    `json:"banner_img"`
	InsLink         string    `json:"ins_link"`
	TwitterLink     string    `json:"twitter_link"`
	WebsiteLink     string    `json:"website_link"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	ContractAddress string    `json:"contract_address"`
	CreatedBy       string    `json:"created_by"`
}

func (q *Queries) ListCollections(ctx context.Context, arg ListCollectionsParams) ([]ListCollectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCollections, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCollectionsRow{}
	for rows.Next() {
		var i ListCollectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Blockchain,
			&i.Owners,
			&i.PaymentToken,
			&i.CreatorEarning,
			&i.FeaturedImg,
			&i.BannerImg,
			&i.InsLink,
			&i.TwitterLink,
			&i.WebsiteLink,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContractAddress,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCollection = `-- name: UpdateCollection :exec
UPDATE collections
SET name = $2, description = $3, owners = $4, featured_img = $5,
    banner_img = $6, ins_link = $7, twitter_link = $8, website_link = $9
WHERE id = $1
`

type UpdateCollectionParams struct {
	ID          int64  `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Owners      string `json:"owners"`
	FeaturedImg string `json:"featured_img"`
	BannerImg   string `json:"banner_img"`
	InsLink     string `json:"ins_link"`
	TwitterLink string `json:"twitter_link"`
	WebsiteLink string `json:"website_link"`
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) error {
	_, err := q.db.ExecContext(ctx, updateCollection,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Owners,
		arg.FeaturedImg,
		arg.BannerImg,
		arg.InsLink,
		arg.TwitterLink,
		arg.WebsiteLink,
	)
	return err
}
